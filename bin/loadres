#!/usr/bin/env python
"""Load results from Modelica_ simulation(s) and provide a Python_ interpreter
to analyze the results.

This script can be executed at the command line.  It will accept as arguments
the names of result files or names of directories with result files.  The
filenames may contain wildcards.  If no arguments are given, the script
provides a dialog to choose a file or folder.  Finally, it provides working
session of `IPython <http://www.ipython.org/>`_ with the results preloaded.
PyLab_ is directly imported (``from pylab import *``) to provide many functions
of NumPy_ and matplotlib_ (e.g., :meth:`sin` and :meth:`plot`).  The essential
classes and functions of ModelicaRes are directly available as well.

**Tutorial:**

First, copy this script (*loadres*) to the current directory along with the 
*examples* folder.  Then, execute the following command:

.. code-block:: sh

   $ loadres examples
   Valid: SimRes('.../examples/ChuaCircuit.mat')
   Valid: SimRes('.../examples/ThreeTanks.mat')
   Valid: LinRes('.../examples/PID.mat')
   Simulation results have been loaded into sim through sims[1].
   A linearization result has been loaded into lin.

where '...' depends on the local system.  If this fails, install the `easygui 
package <http://easygui.sourceforge.net/>_.

We can now explore the simulation results or create plots using the methods in
:class:`~modelicares.simres.SimRes`.  We will look at the first simulation---the
Chua circuit:

.. testsetup::
  >>> from modelicares import SimRes, LinRes
  >>> sims = map(SimRes, ['../examples/ChuaCircuit.mat', '../examples/ThreeTanks.mat'])
  >>> lin = LinRes('examples/PID.mat')

.. code-block:: python

   >>> sim = sims[0]
   >>> print(sim) # doctest: +ELLIPSIS
   Modelica simulation results from ".../examples/ChuaCircuit.mat"

To get the initial value and unit of the current flowing through the inductor 
('L.i'), use :meth:`~modelicares.simres.SimRes.get_FV` and 
:meth:`~modelicares.simres.SimRes.get_unit`:

.. code-block:: python

   >>> sim.get_IV('L.i')
   0.0
   >>> sim.get_unit('L.i')
   'A'

To return the final, minimum, maximum, and mean values, use 
:meth:`~modelicares.simres.SimRes.get_FV`, 
:meth:`~modelicares.simres.SimRes.get_min`, 
:meth:`~modelicares.simres.SimRes.get_max`, and 
:meth:`~modelicares.simres.SimRes.get_mean`:

.. code-block:: python

   >>> sim.get_FV('L.i')
   2.0486615
   >>> sim.get_min('L.i')
   -3.3101323
   >>> sim.get_max('L.i')
   3.9185011
   >>> sim.get_mean('L.i')
   0.43196017

If a variable cannot be found, then suggestions are given:

.. code-block:: python

   >>> sim.get_description('L.ii')
   L.ii is not a valid variable name.
   <BLANKLINE>
   Did you mean one of these?
          L.i
          L.p.i
          L.n.i

   >>> sim.get_description('L.i')
   'Current flowing from pin p to pin n'

To search for variable names, use
:meth:`~modelicares.simres.SimRes.names` with wildcards:

   >>> sim.names('L.p*')
   [u'L.p.i', u'L.p.v']

To see how many variables are in a simulation, use Python_'s built-in 
:meth:`len` function:

.. code-block:: python

   >>> len(sim)
   62

To return all values of 'L.i', use 
:meth:`~modelicares.simres.SimRes.get_values`:

.. code-block:: python

   >>> sim.get_values('L.i') # doctest: +ELLIPSIS
   array([ 0.        , ... 2.04866147], dtype=float32)

To return a tuple of time and value vectors of 'L.i', use 
:meth:`~modelicares.simres.SimRes.get_tuple`:

.. code-block:: python

   >>> sim.get_tuple('L.i') # doctest: +ELLIPSIS
   (array([    0.        , ... 2500.        ], dtype=float32), array([ 0.        , ... 2.04866147], dtype=float32))

or simply index the variable name or provide it as an argument:

.. code-block:: python

   >>> sim['L.i'] # doctest: +ELLIPSIS
   (array([    0.        , ... 2500.        ], dtype=float32), array([ 0.        , ... 2.04866147], dtype=float32))
   >>> sim('L.i') # doctest: +ELLIPSIS
   (array([    0.        , ... 2500.        ], dtype=float32), array([ 0.        , ... 2.04866147], dtype=float32))

To plot 'L.i', use :meth:`~modelicares.simres.SimRes.plot`:

   >>> sim.plot(ynames1='L.i') # doctest: +ELLIPSIS
   (<matplotlib.axes.AxesSubplot object at 0x...>, None)

   >>> import matplotlib.pyplot as plt
   >>> plt.show()

.. testsetup::
   >>> sim.plot(ynames1='L.i') # doctest: +ELLIPSIS
   (<matplotlib.axes.AxesSubplot object at 0x...>, None)
   >>> plt.savefig('examples/ChuaCircuit1.png')
   >>> plt.savefig('examples/ChuaCircuit1.pdf')

.. only:: html

   .. image:: ../examples/ChuaCircuit1.png
      :scale: 70 %
      :alt: plot of Chua circuit

.. only:: latex

   .. figure:: ../examples/ChuaCircuit1.pdf
      :scale: 70 %

      Plot of Chua circuit

Notice that the title and labels were generated automatically.  For a list of 
all available methods, use Python_'s :meth:`help` function:

   >>> help(sim) # doctest: +ELLIPSIS
   Help on SimRes in module modelicares.simres object:
   ...

or see :class:`~modelicares.simres.SimRes`.

Likewise, we can explore the linearization result or create diagrams using the
methods in :class:`~modelicares.linres.LinRes`:

.. code-block:: python

   >>> print lin # doctest: +ELLIPSIS
   Modelica linearization results from ".../examples/PID.mat"
   >>> lin.sys.A
   matrix([[   0.,    0.],
           [   0., -100.]])

.. _Modelica: http://www.modelica.org/
.. _Python: http://www.python.org/
.. _PyLab: http://www.scipy.org/PyLab
.. _NumPy: http://numpy.scipy.org/
.. _matplotlib: http://www.matplotlib.org/
"""
__author__ = "Kevin Davies"
__email__ = "kdavies4@gmail.com"
__copyright__ = "Copyright 2012, Georgia Tech Research Corporation"
__license__ = "BSD-compatible (see LICENSE.txt)"

import os
import time

from sys import argv
#from wx import App, DirSelector, FileSelector
from easygui import fileopenbox, diropenbox

from modelicares import SimRes, LinRes, multiload
from modelicares.gui import boolbox

if __name__ == '__main__':
    DEFAULT_PATH = '../examples'

    def _local_exit(t=0.5):
        """Exit with a message and a delay."""
        print("Exiting...")
        time.sleep(t)
        exit()

    #choice = MessageDialog()

    # Determine the file location(s).
    if len(argv) == 1:
        choice = boolbox("Open one file or all files from a folder?",
                         title="File or folder", choices=('File', 'Folder'),
                         default=0)
        if choice == 0: # File
            loc = fileopenbox(msg="Choose a data file.",
                              default=os.path.join(DEFAULT_PATH, "*.mat"),
                              filetypes=['*.mat'])
            # easygui is ugly, but wx seems to make the working session slow:
            #app = App()
            #fname = FileSelector("Choose a data file.",
            #                     default_path=DEFAULT_PATH, wildcard='*.mat')
            print loc
        elif choice == 1: # Folder
            loc = diropenbox("Choose a folder with data file(s).",
                             default=DEFAULT_PATH)
            #app = App()
            #loc = DirSelector("Choose a folder with data file(s).",
            #                  defaultPath=DEFAULT_PATH)
        else:
            _local_exit()
        if not loc:
            _local_exit()
    elif argv[1] == '--test':
        import doctest
        doctest.testmod()
        exit()
    else:
        loc = argv[1:]

    # Load the file(s).
    sims, lins = multiload(loc)
    n_sims = len(sims)
    if n_sims == 1:
        sim = sims[0]
        del sims
        print("A simulation result has been loaded into sim.")
    elif n_sims > 1:
        print("Simulation results have been loaded into sims[0] through "
              "sims[%i]." % (n_sims-1))#, end="")
    n_lins = len(lins)
    if n_lins == 1:
        lin = lins[0]
        del lins
        print("A linearization result has been loaded into lin.")
    elif n_lins > 1:
        print("Linearization results have been loaded into lins[0] through "
              "lins[%i]." % (n_lins-1))#, end="")
    elif n_sims == 0:
        print("No files were loaded.")
        _local_exit()

    # Open the IPython or standard Python interpreter.
    #    http://writeonly.wordpress.com/2008/09/08/embedding-a-python-shell-in-a-python-script/,
    #    accessed 11/2/2010
    from pylab import *
    from modelicares import *
    try:
        from IPython import embed
        embed()
    except ImportError:
        try:
            # Old version
            from IPython.Shell import IPShellEmbed
            IPShellEmbed(argv=['-noconfirm_exit'])()
            # Note: The -pylab option cannot be embedded (see
            # http://article.gmane.org/gmane.comp.python.ipython.user/1190/match=pylab),
            # so man
        except ImportError:
            from code import InteractiveConsole
            # Calling this with globals ensures that we can see the environment.
            InteractiveConsole(globals()).interact()