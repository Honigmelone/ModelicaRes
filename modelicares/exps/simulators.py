#!/usr/bin/python
# -*- coding: utf-8 -*-
"""Context managers to be used as simulators

In general, the context managers are used like this:

.. code-block:: python

   >>> with context_manager() as simulator: # doctest: +SKIP
   ...     simulator.run(model1, params1)
   ...     simulator.run(model2, params2)
   ...     # ...

For more details, see the documentation for the context managers below:

- :class:`dymola_script` - Write a Dymola\ :sup:`®`-formatted script

- :class:`dymosim` - Run executable models from Dymola\ :sup:`®`

- :class:`fmi` - Simulate FMUs_ via PyFMI_


.. _FMUs: https://www.fmi-standard.org/
.. _PyFMI: http://www.pyfmi.org/
"""
__author__ = "Kevin Davies and Arnout Aertgeerts"
__email__ = "kdavies4@gmail.com"
__copyright__ = ("Copyright 2012-2014, Kevin Davies, Hawaii Natural Energy "
                 "Institute, and Georgia Tech Research Corporation")
__license__ = "BSD-compatible (see LICENSE.txt)"

import os
import sys

from collections import deque
from datetime import date
from functools import partial
from multiprocessing import Pool
from shutil import copy, move, rmtree
from . import read_options, read_params, write_options, write_params
from ..util import ParamDict, cleanpath, run_in_dir, dict_to_lists

# OS-dependent strings
EXE = '.exe' if os.name == 'nt' else '' # File extension for an executable
EXEC_PREFIX = '' if os.name == 'nt' else './' # Prefix to execute a file


class dymola_script(object):

    """Context manager to write a Dymola\ :sup:`®`-formatted script

    **Initialization parameters (defaults in parentheses):**

    - *fname* ("run_sims.mos"): Name of the script file to be written, relative
      to the current directory

    - *command* ('simulateModel'): Simulation or other command to
      Dymola\ :sup:`®`

         Besides 'simulateModel', this can be 'linearizeModel' to create a state
         space representation or 'translateModel' to create executables without
         running them.

    - *working_dir* (''): Working directory where the executable, log files,
      etc. are initially created (relative to the current directory)

         '~' may be included to represent the user directory.

    - *results* (['dsin.txt', 'dslog.txt', 'dsres.mat', 'dymolalg.txt',
      'dymosim%x']): List of files to copy to the results folder, besides
      dsfinal.txt

         Each entry is the name or path of a file that is generated by the
         command.  The path is relative to *working_dir*.  '%x' may be included
         in the name to represent '.exe' if the operating system is Windows and
         '' otherwise.  The result folders are named by the simulation number
         and placed within the folder contains the script (*fname*).

    - *packages* ([]): List of Modelica_ packages that should be preloaded or
      scripts that should be run before the experiments

         Each may be a "\*.mo" file, a folder that contains a "package.mo" file,
         or a "\*.mos" file.  The path may be absolute or relative to
         *working_dir*.  The Modelica Standard Library does not need to be
         included since it is loaded automatically.  If an entry is a script
         ("\*.mos"), it is run from its folder.

    - *\*\*options*: Additional keyword arguments for *command*

         Any option with a value of *None* will be skipped.

         These arguments can also be added, modified, or removed after
         initialization.  Please see Example 2 below.

         If *command* is 'simulateModel', then the following keywords may be
         used.  The defaults (in parentheses) are applied by Dymola\ :sup:`®`,
         not by this context manager.

         - *startTime* (0): Start of simulation

         - *stopTime* (1): End of simulation

         - *numberOfIntervals* (0): Number of output points

         - *outputInterval* (0): Distance between output points

         - *method* ("Dassl"): Integration method

         - *tolerance* (0.0001): Tolerance of integration

         - *fixedstepsize* (0): Fixed step size for Euler

         - *resultFile* ("dsres.mat"): Where to store result

    **Example 1 (a single simulation):**

    .. code-block:: python

       >>> from modelicares.exps.simulators import dymola_script

       >>> with dymola_script("examples/ChuaCircuit/run_sims1.mos", stopTime=2500) as simulator: # doctest: +ELLIPSIS
       ...     simulator.run('Modelica.Electrical.Analog.Examples.ChuaCircuit')
       Starting to write the Dymola script...
       Run 1:  simulateModel(...)
       Finished writing the Dymola script.

    This generates a summary of the runs in *examples/ChuaCircuit/runs.tsv*:

    ===== ============= ============= ===============================================
    Run # Command       Options       Model & parameters
    ===== ============= ============= ===============================================
    1     simulateModel stopTime=2500 Modelica.Electrical.Analog.Examples.ChuaCircuit
    ===== ============= ============= ===============================================

    and the following script in *examples/ChuaCircuit/run_sims1.mos*:

    .. code-block:: modelica

       // Dymola script written by ModelicaRes...
       import Modelica.Utilities.Files.copy;
       import Modelica.Utilities.Files.createDirectory;
       Advanced.TranslationInCommandLog = true "Also include translation log in command log";
       cd("...");
       destination = ".../examples/ChuaCircuit/";

       // Run 1
       ok = simulateModel(problem="Modelica.Electrical.Analog.Examples.ChuaCircuit", stopTime=2500);
       if ok then
           savelog();
           dest = destination + "1/";
           createDirectory(dest);
           copy("dsin.txt", dest + "dsin.txt", true);
           copy("dslog.txt", dest + "dslog.txt", true);
           copy("dsres.mat", dest + "dsres.mat", true);
           copy("dymosim", dest + "dymosim...", true);
           copy("dymolalg.txt", dest + "dymolalg.txt", true);
       end if;
       clearlog();

       exit();

    where ``...`` depends on the local system.

    **Example 2 (simulating with different options):**

    The default options can also be modified or removed after establishing the
    context:

    .. code-block:: python

       >>> from modelicares.exps.simulators import dymola_script

       >>> with dymola_script("examples/ChuaCircuit/run_sims2.mos", stopTime=250) as simulator: # doctest: +ELLIPSIS
       ...     simulator.run('Modelica.Electrical.Analog.Examples.ChuaCircuit', stopTime=2500)
       ...     simulator.run('Modelica.Electrical.Analog.Examples.ChuaCircuit')
       ...     del simulator.stopTime
       ...     simulator.run('Modelica.Electrical.Analog.Examples.ChuaCircuit')
       ...     simulator.stopTime = 25
       ...     simulator.run('Modelica.Electrical.Analog.Examples.ChuaCircuit')
       Starting to write the Dymola script...
       Run 1:  simulateModel(...)
       Run 2:  simulateModel(...)
       ...
       Finished writing the Dymola script.

    Initially the stop time is set at 250 s, but in the first run it is
    temporarily overwritten to 2500 s.  In the second run, it falls back to its
    initial setting.  The stop time is removed before the third run and then set
    to 25 s for the final run.

    This generates the following table:

    ===== ============= ============= ===============================================
    Run # Command       Options       Model & parameters
    ===== ============= ============= ===============================================
    1     simulateModel stopTime=2500 Modelica.Electrical.Analog.Examples.ChuaCircuit
    2     simulateModel stopTime=250  Modelica.Electrical.Analog.Examples.ChuaCircuit
    3     simulateModel               Modelica.Electrical.Analog.Examples.ChuaCircuit
    4     simulateModel stopTime=25   Modelica.Electrical.Analog.Examples.ChuaCircuit
    ===== ============= ============= ===============================================

    and a corresponding script in *examples/ChuaCircuit/run_sims2.mos*.

    **Example 3 (full-factorial design of experiments):**

    Multiple parameters can be adjusted using functions from the
    :mod:`~modelicares.exps.doe` module.

    .. code-block:: python

       >>> from modelicares.exps.simulators import dymola_script
       >>> from modelicares import doe

       >>> with dymola_script("examples/ChuaCircuit/run_sims3.mos") as simulator: # doctest: +ELLIPSIS
       ...     for params in doe.fullfact({'C1.C': [8, 10], 'L.L': [18, 20]}):
       ...         simulator.run("Modelica.Electrical.Analog.Examples.ChuaCircuit", params=params)
       Starting to write the Dymola script...
       Run 1:  simulateModel(...)
       ...
       Run 4:  simulateModel(...)
       Finished writing the Dymola script.

    This generates the following table:

    ===== ============= ======= ==================================================================
    Run # Command       Options Model & parameters
    ===== ============= ======= ==================================================================
    1     simulateModel         Modelica.Electrical.Analog.Examples.ChuaCircuit(C1(C=8), L(L=18))
    2     simulateModel         Modelica.Electrical.Analog.Examples.ChuaCircuit(C1(C=10), L(L=18))
    3     simulateModel         Modelica.Electrical.Analog.Examples.ChuaCircuit(C1(C=8), L(L=20))
    4     simulateModel         Modelica.Electrical.Analog.Examples.ChuaCircuit(C1(C=10), L(L=20))
    ===== ============= ======= ==================================================================

    and a corresponding script in *examples/ChuaCircuit/run_sims3.mos*.


    .. _Modelica: http://www.modelica.org/
    """

    def __init__(self, fname="run_sims.mos", command='simulateModel',
                 working_dir='',
                 results=['dsin.txt', 'dslog.txt', 'dsres.mat', 'dymolalg.txt',
                          'dymosim%x'],
                 packages=[], **options):
        """Upon initialization, start writing the script.

        See the top-level class documentation.
        """

        # Pre-process and store the arguments.
        fname = cleanpath(fname)
        self._command = command
        working_dir = cleanpath(working_dir)
        results_dir = os.path.dirname(fname)
        for i, result in enumerate(results):
            results[i] = result.replace('%x', EXE)
        self._results = results
        self._default_options = options

        # Open the script.
        print("Starting to write the Dymola script...")
        mos = open(fname, 'w')
        self._mos = mos

        # Write the header.
        mos.write('// Dymola script written by ModelicaRes %s\n'
                  % date.isoformat(date.today()))
        mos.write('import Modelica.Utilities.Files.copy;\n')
        mos.write('import Modelica.Utilities.Files.createDirectory;\n')
        mos.write('Advanced.TranslationInCommandLog = true "Also include '
                  'translation log in command log";\n')
        mos.write('cd("%s");\n' % working_dir)
        for package in packages:
            if package.endswith('.mos'):
                mos.write('cd("%s");\n' % os.path.dirname(package))
                mos.write('RunScript("%s");\n' % os.path.basename(package))
            else:
                if package.endswith('.mo'):
                    mos.write('openModel("%s");\n' % package)
                else:
                    mos.write('openModel("%s");\n' % os.path.join(package,
                                                                  'package.mo'))
            mos.write('cd("%s");\n' % working_dir)
        mos.write('destination = "%s";\n\n'
                  % (os.path.normpath(results_dir) + os.path.sep))
        # Sometimes Dymola opens with an error; simulate any model to clear the
        # error.
        # mos.write('simulateModel("Modelica.Electrical.Analog.Examples.'
        #           'ChuaCircuit");\n\n')

        # Start the run log.
        log = open(os.path.join(results_dir, "runs.tsv"), 'w')
        log.write("Run #\tCommand\tOptions\tModel & parameters\n")
        self._log = log

        # Start counting the run() calls.
        self.simulation = 0

    def __delattr__(self, attr):
        """Delete a default option.
        """
        del self._default_options[attr]

    def __getattr__(self, attr):
        """If an unknown attribute is requested, look for it in the dictionary
        of default options.
        """
        return self._default_options[attr]

    def __setattr__(self, attr, value):
        """Add known attributes directly, but unknown attributes go to the
        dictionary of default options.
        """
        if attr in ('_command', '_results', '_options', 'simulation', 'interval',
                    '_log', '_mos'):
            object.__setattr__(self, attr, value) # Traditional method
        else:
            self._default_options[attr] = value

    def __enter__(self):
        """Enter the context of the simulator.
        """
        # Everything has been done in __init__, so just do this:
        return self

    def __exit__(self, *exc_details):
        """Exit the context of the simulator.
        """
        # Write the command to exit the simulation environment.
        # Otherwise, the script will hang until it's closed manually.
        self._mos.write("exit();\n")
        self._mos.close()

        self._log.close()
        print("Finished writing the Dymola script.")

    def run(self, model=None, params={}, **options):
        """Write commands to run and save the results of a single experiment.

        **Parameters:**

        - *model*: String representing the name of the model, including the
          full Modelica_ path (in dot notation)

             If *model* is *None*, then the model is not included in the
             command.  Dymola\ :sup:`®` will use the last translated model.

        - *params*: Dictionary of parameter names and values to be set within
          the model

             The keys or variable names in this dictionary must indicate the
             hierarchy within the model---either in Modelica_ dot ('.') notation
             or via nested dictionaries.  If *model* is *None*, then *params* is
             ignored.  Python_ values are automatically represented in Modelica_
             syntax (see :meth:`~modelicares.exps.ParamDict.__str__`).
             Redeclarations and other prefixes must be included in the keys
             along with the class names (e.g.,
             ``params={'redeclare package Medium': 'Modelica.Media.Air.MoistAir'}``).

             Any item with a value of *None* is skipped.

        - *\*\*options*: Additional or modified keyword arguments for the
          command chosen upon initialization (see the top-level documentation of
          this context manager, :class:`dymola_script`)

             Any option with a value of *None* will be skipped.

             These are applied only for the current simulation.  They override
             the options given at initialization or set via attribute access.

        Please see the examples in the top-level documentation of
        :class:`dymola_script`.
        """
        # Increment the number of runs and reset the number of periods.
        self.simulation += 1
        self.interval = 1

        # Retrieve some attributes.
        simulation = self.simulation
        mos = self._mos
        command = self._command
        opts = self._default_options.copy()
        opts.update(options)

        # Write the command to run the model.
        mos.write('// Run %i\n' % simulation)
        problem = '"%s%s"' % (model, ParamDict(params)) if model else None
        call = '%s%s' % (command, ParamDict(opts, problem=problem))
        mos.write('ok = %s;\n' % call)

        # Write commands to save the results and clear Dymola's log file.
        mos.write('if ok then\n')
        mos.write('    savelog();\n')
        mos.write('    dest = destination + "%s%s";\n' % (simulation, os.path.sep))
        mos.write('    createDirectory(dest);\n')
        for result in self._results:
            new_name = str(self.interval).join(os.path.splitext(result))
            mos.write('    copy("%s", dest + "%s", true);\n'
                      % (result, new_name))
        mos.write('    copy("dsfinal.txt", dest + "dsfinal.txt", true);\n'
                  % (result, new_name))
        mos.write('end if;\n')
        mos.write('clearlog();\n\n')

        # Add an entry to the run log.
        self._log.write('\t'.join([str(simulation),
                                       command,
                                       str(ParamDict(opts))[1:-1],
                                       problem[1:-1] if problem else ''])
                            + '\n')
        print('Run %s:  %s' % (simulation, call))

    # TODO: Consider adding a cont() method like in dymosim below.  The main
    # issue is that it's impossible to access stopTime programmatically in
    # Dymola (due to problems with assignment from Dymola's getExperiment()
    # function). Therefore, it's impossible to set the new stopTime based on
    # duration.

class dymosim(object):

    """Context manager to run executable models from Dymola\ :sup:`®`

    **Initialization parameters (defaults in parentheses):**

    - *command* ('-s'): Simulation or other action command to dymosim.

         Besides '-s', this can be '-l' to create a state space representation.

    - *results_dir* (''): Directory in which to store the results, relative to
      the current directory

    - *result_files* (['dslog.txt']): List of result files to keep, besides the
      trajectory (dsres.mat), initial values (dsin.txt), and final values
      (dsfinal.txt)

         Each entry is the name or path of a file that is generated by the
         executable.  The path is relative to the directory where the model
         resides (see :meth:`run`).

    - *debug* (*False*): If *True*, print the dymosim messages.

         In debugging mode, the simulations are run synchronously.

    - *\*\*options*: Default adjustments to the simulation settings under
      "Experiment parameters", "Method tuning parameters", and "Output
      parameters" in the initialization file (e.g., dsin.txt)

         See the initialization file for more information.  The common
         parameters are those under "Experiment parameters".  Note that they are
         named differently than those for :class:`dymola_script`:

         - *StartTime* (compare to *startTime*): Time at which integration
           starts

         - *StopTime* (compare to  *stopTime*): Time at which integration stops

         - *Increment* (compare to *outputInterval*): Communication step size,
           if > 0

         - *nInterval* (compare to *numberOfIntervals*): Number of communication
           intervals, if > 0

         - *Tolerance* (compare to *tolerance*): Relative precision of signals
           for simulation

         - *MaxFixedStep* (compare to *fixedstepsize*): Maximum step size of
           fixed step size integrators, if > 0.0

         - *Algorithm* (compare to *method*): Integration algorithm (accepts an
           integer instead of a string)

         Any option with a value of *None* will be skipped.

         These arguments can also be added, modified, or removed after
         initialization.  Please see Example 2 of :class:`dymola_script`; the
         same approach can be used with this context manager (:class:`dymosim`).

    The results are placed in *results_dir* in subfolders named by the
    simulation number.  Within each subfolder, the files in the *results* list
    as well as the trajectory (dsres.mat) and initial values (dsin.txt) are
    renamed with the interval number just before the file extension.  The
    :meth:`run` method creates interval number 1 and returns a
    :class:`DymosimSimulation`.  Its :meth:`DymosimSimulation.cont` method
    continues with intervals 2, 3, etc.  The final values (dsfinal.txt) are
    those of the last period and are copied directly.

    **Example:**

    .. code-block:: python

       >>> from modelicares.exps.simulators import dymosim

       >>> with dymosim(StopTime=2500) as simulator: # doctest: +ELLIPSIS
       ...     simulator.run('examples/ChuaCircuit/dymosim')

    Notice that this is similar to Example 1 of :class:`dymola_script`.
    Likewise, the form of Examples 2 and 3 for that context manager holds for
    this one.
    """

    def __init__(self, command='-s', results_dir='', result_files=['dslog.txt'],
                 debug=False, **options):
        """Initialize the simulator.

        See the top-level class documentation.
        """
        # No simulations yet
        self.simulation_count = 0

        # Create the results directory.
        self._results_dir = cleanpath(results_dir)
        if not os.path.isdir(self._results_dir):
            os.makedirs(self._results_dir)

        # Store the other arguments.
        self._command = command
        self._result_files = result_files
        self._debug = debug
        self._default_options = options

        # In debug mode, the output must be printed for each simulation as it
        # runs, so it's necessary to run synchronously.

    def __enter__(self):
        """Enter the context of the simulator.
        """
        # Prepare for asynchronous simulation, unless debugging is enabled.
        self._pool = None if debug else Pool()

        # Open the log.
        self._log = open(os.path.join(self._results_dir, "runs.tsv"), 'w')
        self._log.write("Simulation #\tInterval #\tOptions\tExecutable"
                        "\tInitial values & parameters\n")

        return self

    def __exit__(self, *exc_details):
        """Exit the context of the simulator.
        """
        self._log.close()
        if self._pool:
            self._pool.close()
            self._pool.join() # Wait for all processes to exit.

    def __delattr__(self, attr):
        """Delete a default option.
        """
        del self._default_options[attr]

    def __getattr__(self, attr):
        """If an unknown attribute is requested, look for it in the dictionary
        of default options.
        """
        return self._default_options[attr]

    def __setattr__(self, attr, value):
        """Add known attributes directly, but unknown attributes go to the
        dictionary of default options.
        """
        if attr in ('_command', '_debug', 'default_options', '_log', '_pool',
                    '_results_dir', '_result_files', 'simulation_count'):
            object.__setattr__(self, attr, value) # Traditional method
        else:
            self._default_options[attr] = value

    def _write_log(self, simulation_count, interval_count, options, executable,
                   parameters):
        """Write a log entry for a model run or continuation with *parameters*.
        """
        self._log.write('\t'.join([str(simulation_count),
                                   str(interval_count),
                                   str(ParamDict(options))[1:-1],
                                   executable,
                                   str(ParamDict(parameters))[1:-1]])
                        + '\n')

    def run(self, model='dymosim', params={}, **options):
        r"""Run and save the results of a single experiment.

        **Parameters:**

        - *model*: String representing the directory and base name of the model
          executable

             '.exe' will be added if the operating system is Windows.

             The initialization file is expected at *model* + '_dsin.txt'.
             However, if the base name (without directory) is 'dymosim', then
             'dsin.txt' will be used instead from the same directory.  If the
             initialization file does not exist, it will be created.

        - *params*: Dictionary of names and values of parameters and variables
          with tunable initial values to be set within the model

             The keys or variable names in this dictionary must indicate the
             hierarchy within the model---either in Modelica_ dot ('.') notation
             or via nested dictionaries.  Due to the format of the
             initialization files, arrays must be broken into scalars by
             indicating the indices (Modelica_ 1-based indexing) in the key
             along with the variable name.  Also, enumerations and Booleans must
             be given as their unsigned integer equivalents (e.g., 0 for
             *False*).  Strings and prefixes are not supported.

             Any item with a value of *None* is skipped.

        - *\*\*options*: Adjustments to the simulation settings under
          "Experiment parameters", "Method tuning parameters", and "Output
          parameters" in the initialization file

             Any option with a value of *None* will be skipped.

             For more common parameters, see the initialization parameters in
             the top-level documentation of this context manager,
             :class:`dymosim`.

             These are applied only for the current simulation.  They override
             the options given at initialization or set via attribute access.

        Please see the example in the top-level documentation of
        :class:`dymosim`.
        """
        # Update the simulation options.
        current_options = self._default_options.copy()
        current_options.update(options)

        # Start the simulation.
        self.simulation_count += 1
        return DymosimSimulation(self, model, params, current_options,
            write_log=partial(self._write_log,
                              simulation_count=self.simulation_count),
            execute=self._pool._apply_async if self._pool else None)

        # Create the results directory.
        self._results_dir = cleanpath(results_dir)
        if not os.path.isdir(self._results_dir):
            os.makedirs(self._results_dir)

        # Store the other arguments.
        self._command = command
        self._result_files = result_files
        self._debug = debug
        self._default_options = options

        # Locate the original dsin file.  Create it if necessary.
        if model_base == 'dymosim':
            dsin_name = 'dsin.txt'
        else:
            dsin_name = model_base + '_dsin.txt'
        if not os.path.isfile(os.path.join(model_dir, dsin_name)):
            # Create the file.
            run_in_dir([EXEC_PREFIX + self.current_executable, '-i',
                        dsin_name], model_dir)
        orig_dsin_path = os.path.join(model_dir, dsin_name)

        # Create the results folder and copy the original dsin file into it.
        if not os.path.isdir(results_dir):
            os.makedirs(results_dir)

class Simulation(object):

    """Simulation class

    This class is returned by :meth:`dymosim.run` or :meth:`fmi.run`.  It is not
    intended for direct instantiation.

    **Methods:**

    - :meth:`cont` - Continue the simulation from the end of the last interval.
    """

    def __init__(self, model, params, options, write_log, execute):
        """Initialize the dymosim simulation.
        """

        self._model = model
        self._queue = dequeue([(params, options)])
        self._process_queue()

        # TODO set these:
        self.results_dir
        self.dsin_path
        self.options

        self._execute = execute
        self._write_log = write_log

        # Update the current model and determine the paths.
        self.current_model = model
        model_dir = self.current_model_dir
        model_base = self.current_model_base
        results_dir = self.current_results_dir
        dsin_path = self.current_dsin_path

        # Write the parameters and options, run the model, and save the results.
        _run(options, executable, dsin_path, model_dir, results_dir, simulation,
             interval, params={}, command=None, results=None, debug=False)

        if self.simulator._pool:
            # Asynchronous
            return self._execute(
                self._run,
                [],
                dict(options=self.current_options,
                     executable=self.current_executable,
                     dsin_path=self.current_dsin_path,
                     model_dir=self.current_model_dir,
                     results_dir=self.current_results_dir,
                     simulation=self.simulation,
                     interval=self.interval,
                     params=params,
                     command=self._command,
                     results=self._results))
        # TODO except TypeError:
            # Synchronous
            self._run(options=self.current_options,
                      executable=self.current_executable,
                      dsin_path=self.current_dsin_path,
                      model_dir=self.current_model_dir,
                      results_dir=self.current_results_dir,
                      simulation=self.simulation,
                      interval=self.interval,
                      params=params,
                      command=self._command,
                      results=self._results,
                      debug=True)

        @property
        def current_results_dir(self):
            """The current results directory
            """
            return os.path.join(self._results_dir, str(self.simulation))

        try:
            self.stop_time = options['StopTime']
        except KeyError:
            self.stop_time = read_options('StopTime', self.dsin_path)

        if options:
            write_options(options, dsin_path)

        # Add an entry to the run log.
        self.interval_count = 1
        self._write_log = partial(write_log, interval_count=self.interval_count,
                                  executable=self.executable)

        self._write_log = partial(_write_log, interval=self.interval_count)

        # Write the model parameters and initial conditions.
        copy(orig_dsin_path, dsin_path)
        write_params(params, dsin_path)

        # Create the working directory.
        working_dir = os.path.join(model_dir, 'temp_%i_%i' % (sim_num, int_num))
        if os.path.isdir(working_dir):
            shutil.rmtree(working_dir)
        os.mkdir(working_dir)

        # Run the model.
        dsres_path = os.path.join(results_dir, 'dsres%i.mat' % int_num)
        dsfinal_path = os.path.join(results_dir, 'dsfinal.txt')
        args = [os.path.join(model_dir, executable), command, '-f',
                dsfinal_path, dsin_path, dsres_path]
        run_in_dir(args, working_dir, debug=debug)

        # Save the other results.
        for result in results:
            source = os.path.join(working_dir, result)
            destination = os.path.join(results_dir,
                str(interval).join(os.path.splitext(result)))
            move(source, destination)

        # Remove the working directory and its contents.
        rmtree(working_dir)

        self._write_log(self, options, parameters)

    def cont(self, duration, params={}):
        """Continue the simulation from the end of the last interval (using the
        same model).

        **Parameters:**

        - *duration*: Number of additional seconds to simulate

        - *params*: Dictionary of names and values of parameters to be adjusted
          within the model

             By default, the parameters remain as they were in the last
             :meth:`run`.  See that method for details on *params*.

        .. warning::

           Be careful not to use *params* to adjust variables with tunable
           initial values.  Otherwise, the new simulation will not continue
           where the last one left off.
        """
        # Replace the initialization file with the old final values file.
        move(os.path.join(self.results_dir, 'dsfinal.txt'), self.dsin_path)

        self._queue.append((duration, options, params))
        #TODO if not running:
        #    self._run_queue(...)

        # Establish the start and stop times.
        self.options['StartTime'] = self.stop_time
        self.stop_time += duration
        self.options['StopTime'] = self.stop_time

        # Add an entry to the run log.
        interval += 1
        self._write_log(params, interval)

    def _process_queue(self, interval=1):
        """Run the simulation intervals from the queue.
        """

        # Write the options and parameters, run the model, and save the results.
        try:
            dsin_src, dsin_dest, options, params = self._queue.popleft()
        except IndexError:
            return # No more intervals to run
        try:
            # Asynchronous
            return self._execute(self._run, [],
                                 dict(options=options,
                                      params=params,
                                      command=self._command,
                                      results=self._results),
                                 callback=self._run_queue) # Recursive
        except TypeError:
            # Synchronous
            self._run(options=options,
                      params=params,
                      command=self._command,
                      results=self._results,
                      debug=True)

    @property
    def current_dsin_path(self):
        """The path to the current initial values file
        """
        return os.path.join(self.current_results_dir,
                            'dsin%i.txt' % self.interval)

    @property
    def current_executable(self):
        """The current model executable, without directory
        """
        return self.current_model_base + EXE

    @property
    def current_model(self):
        """The currently selected model
        """
        return self._current_model

    @current_model.setter
    def current_model(self, value):
        """Set the current model.
        """
        if value:
            self._current_model = value
        else:
            assert self._current_model, "The model must be specified."
        assert os.path.isfile(self.current_model + EXE), (
            'The executable (%s) cannot be found in the "%s" folder.'
            % (self.current_executable,
               os.path.abspath(self.current_model_dir)))

    @property
    def current_model_base(self):
        """Base name of the current model (without directory and possible '.exe'
        extension)
        """
        try:
            return os.path.basename(self.current_model)
        except AttributeError:
            return None

    @property
    def current_model_dir(self):
        "Directory of the current model"
        try:
            return os.path.dirname(self.current_model)
        except AttributeError:
            return None

    @property
    def result(self):
        pass # TODO

    @property
    def done(self):
        return self._process.done()

    def cancel(self):
        return self._process.cancel()

    @property
    def cancelled(self):
        return self._process.cancelled()

    @property
    def running(self):
        return self._process.running()

    @property
    def exception(self):
        return self._process.exception()

class fmi(object):

    """Context manager to simulate FMUs_ via PyFMI_

    .. Warning:: This context manager has not been implemented yet. TODO

    **Example:**

    .. code-block:: python

       >>> from modelicares.exps.simulators import fmi

       >>> with fmi(stopTime=2500) as simulator:
       ...     simulator.run('examples/ChuaCircuit.fmu')

    For more complicated scenarios, use the same form as in Examples 2 and 3
    in the :class:`dymola_script` documentation.
    """

    def __init__(self, results_dir='', **options):
        """Upon initialization, establish some settings.

        See the top-level class documentation.
        """

        # Pre-process and store the arguments.
        self._results_dir = cleanpath(results_dir)
        self._default_options = options

        # Dictionary for in memory results.  If the option
        # result_handling='memory' is set, no output txt files will be written.
        self.memory_result = {}

        # Start the run log.
        log = open(os.path.join(results_dir, "runs.tsv"), 'w')
        log.write("Run #\tPeriod #\tOptions\tExecutable\tInitial values & "
                      "parameters\n")
        self._log = log

        # Start counting the run() calls.
        self.simulation = 0

    def __delattr__(self, attr):
        """Delete a default option.
        """
        del self._default_options[attr]

    def __getattr__(self, attr):
        """If an unknown attribute is requested, look for it in the dictionary
        of default options.
        """
        return self._default_options[attr]

    def __setattr__(self, attr, value):
        """Add known attributes directly, but unknown attributes go to the
        dictionary of default options.
        """
        if attr in ('_results_dir', '_options', 'simulation',
                    '_log', '_current_model', 'memory_result', 'fmu'):
            object.__setattr__(self, attr, value) # Traditional method
        else:
            self._default_options[attr] = value

    def __enter__(self):
        """Enter the context of the simulator.
        """
        # Everything has been done in __init__, so just do this:
        return self

    def __exit__(self, *exc_details):
        """Exit the context of the simulator.
        """
        self._log.close()

    def _paths(self, model=None):
        """Given a FMU's path (*model*) and the internal state, return a tuple
        of:
        1. the FMU's directory
        2. the results directory

        Also, confirm that the FMU exists.

        Save the model.  If *model* is *None*, then use the last model.
        """

        # Locate the model.
        if model is None:
            model = self._current_model
        else:
            self._current_model = model
        assert os.path.isfile(model), (
            'The FMU (%s) cannot be found.' % os.path.abspath(model))

        # Return the directories.
        model_dir = os.path.dirname(model)
        results_dir = os.path.join(self._results_dir, str(self.simulation))
        return model_dir, results_dir

    def load(self, fmu_path, results_dir):
        """Load the FMU for continued simulation in :meth:`continue_run`.
        """

        import pyfmi

        if 'log_level' in self._default_options:
            self.fmu = pyfmi.load_fmu(fmu_path, log_level=self.log_level)
        else:
            self.fmu = pyfmi.load_fmu(fmu_path)

        # Initialize the fmu, only call setup_experiment for FMUs 2.0
        try:
            self.fmu.setup_experiment()
            version = 2
        except AttributeError:
            version = 1

        self.fmu.initialize()

        # Copy the log file to the result directory
        log = ''
        if version == 1:
            log = self.fmu.get_identifier()
        if version == 2:
            log = self.fmu.get_name()
        log += '_log.txt'
        source = os.path.join(os.getcwd(), log)
        destination = os.path.join(results_dir, 'log%i.txt' % self.interval)
        move(source, destination)

    def move_mat_file(self):
        """TODO
        """
        results_dir = self._paths()[1]
        source = os.path.join(os.getcwd(), 'Model_internal.mat')
        destination = os.path.join(results_dir, 'result.mat')
        copy(source, destination)

    def _run(self, params, options, model_dir, results_dir):
        """Write the given model parameters and initial values (*params*) and
        *results_dir*.  TODO Send the simulation options (*options*) to the FMU and
        save the results to the start and stop times are given in the same way
        as in :class:`dymosim`.

        Also write to the log file.
        """
        # Determine the file locations.
        dsres_path = os.path.join(results_dir, 'dsres%i.txt' % self.interval)

        # Write the simulation options.
        simulation_options = self.fmu.simulate_options()

        for key, value in simulation_options.iteritems():
            # Set the simulator options
            if key in self._default_options:
                simulation_options[key] = self._default_options[key]
            # Overwrite simulator options with the options of the run method if given
            if key in options:
                simulation_options[key] = options[key]

        simulation_options['initialize'] = False
        simulation_options['result_file_name'] = dsres_path

        # Set start and stop times to be consistent across different simulators
        if 'StartTime' in options:
            start_time = options['StartTime']
        else:
            start_time = self.fmu.get_default_experiment_start_time()
        if 'StopTime' in options:
            stop_time = options['StopTime']
        else:
            stop_time = self.fmu.get_default_experiment_stop_time()

        # Set the simulation parameters
        self.fmu.set(params.keys(), params.values())

        # Run the model.
        self.memory_result[self.simulation][self.interval] = self.fmu.simulate(
            start_time=start_time,
            final_time=stop_time,
            options=simulation_options
        )

        # Add an entry to the run log.
        self._log.write('\t'.join([str(self.simulation),
                                       str(self.interval),
                                       str(ParamDict(options))[1:-1],
                                       self.fmu.get_name(),
                                       str(ParamDict(params))[1:-1]])
                            + '\n')

    def run(self, model='model.fmu', params={}, **options):
        r"""Run and save the results of a single experiment.

        **Parameters:**

        - *model*: String representing the directory and base name of the fmu

             If *model* is *None*, then the previous model will be used.

        - *params*: Dictionary of names and values of parameters and variables
          with tunable initial values to be set within the model

             The keys or variable names in this dictionary must indicate the
             hierarchy within the model---either in Modelica_ dot ('.') notation
             or via nested dictionaries.  Due to the format of the
             initialization files, arrays must be broken into scalars by
             indicating the indices (Modelica_ 1-based indexing) in the key
             along with the variable name.  Also, enumerations and Booleans must
             be given as their unsigned integer equivalents (e.g., 0 for
             *False*).  Strings and prefixes are not supported.

             Any item with a value of *None* is skipped.

        - *\*\*options*: Adjustments to the simulation settings of an fmu and
          the start and stop times

             Any option with a value of *None* will be skipped.

             These are applied only for the current simulation.  They override
             the options given at initialization or set via attribute access.

        Please see the example in the top-level documentation of
        :class:`fmi`.
        """
        # Increment the number of runs and reset the number of periods.
        self.simulation += 1
        self.interval = 1
        self.memory_result[self.simulation] = {}

        # Determine the file locations.
        model_dir, results_dir = self._paths(model)

        # Create the results folder.
        if not os.path.isdir(results_dir):
            os.makedirs(results_dir)

        # Load the fmu, write the parameters and options, run the model, and
        # save the results.
        self.load(model, results_dir)
        self._run(params, options, model_dir, results_dir)

    def continue_run(self, duration, params={}, **options):
        """Continue the last run (using the same model).

        **Parameters:**

        - *duration*: Number of additional seconds to simulate

        - *params*: Dictionary of names and values of parameters to be adjusted
          within the model

             By default, the parameters remain as they were in the last
             :meth:`run`.  See that method for details on *params*.

        - *\*\*options*: Adjustments to the simulation settings under
          "Experiment parameters", "Method tuning parameters", and "Output
          parameters" in the initialization file

             By default, the options remain as they were in the last
             :meth:`run`.  See that method for details.

             StartTime and StopTime are ignored because they are determined
             automatically from *duration* and the stop time of the last
             simulation.
        """
        # Increment the number of periods.
        self.interval += 1

        # Determine the file locations.
        model_dir, results_dir = self._paths()

        # Run the simulation with the proper start and stop times.
        start_time = self.fmu.time
        options = {
            'StartTime': start_time,
            'StopTime': start_time + duration
        }
        self._run(params, options, model_dir, results_dir)

if __name__ == '__main__':
    # Test the contents of this file.

    import doctest
    doctest.testmod()
